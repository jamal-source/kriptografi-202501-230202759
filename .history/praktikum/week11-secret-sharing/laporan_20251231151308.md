# Laporan Praktikum Kriptografi
Minggu ke-: X  
Topik: [judul praktikum]  
Nama: [Nama Mahasiswa]  
NIM: [NIM Mahasiswa]  
Kelas: [Kelas]  

---

## 1. Tujuan
Setelah mengikuti praktikum ini, mahasiswa diharapkan mampu:
1. Memahami konsep Secret Sharing dan implementasinya menggunakan algoritma Shamir.
2. Membuat program untuk membagi rahasia menjadi beberapa bagian (shares).
3. Merekaonstruksi rahasia dari kombinasi shares yang cukup.
4. Menganalisis keamanan dan aplikasi praktis dari Secret Sharing.

---

## 2. Dasar Teori
Secret Sharing adalah teknik kriptografi yang memungkinkan pembagian rahasia menjadi beberapa bagian (shares) sehingga rahasia hanya dapat direkonstruksi jika sejumlah minimum shares dikumpulkan. Algoritma Shamir's Secret Sharing menggunakan interpolasi polinomial untuk membagi rahasia menjadi n shares, di mana k shares diperlukan untuk rekonstruksi.

Dalam Shamir's Secret Sharing, rahasia S direpresentasikan sebagai konstanta dalam polinomial f(x) = a0 + a1*x + a2*x^2 + ... + ak-1*x^(k-1), di mana a0 = S. Shares dibuat dengan mengevaluasi polinomial pada titik-titik berbeda (x1, f(x1)), (x2, f(x2)), dll. Rekonstruksi dilakukan dengan interpolasi Lagrange untuk menemukan kembali koefisien a0.

Teknik ini berguna dalam sistem keamanan di mana rahasia harus dilindungi dari kehilangan atau kompromi. Misalnya, dalam sistem perbankan, kunci master dapat dibagi menjadi beberapa shares yang disimpan oleh orang berbeda, sehingga tidak ada satu orang yang dapat mengakses rahasia tersebut sendirian.

---

## 3. Alat dan Bahan
(- Python 3.x  
- Visual Studio Code / editor lain  
- Git dan akun GitHub  
- Library tambahan (misalnya pycryptodome, jika diperlukan)  )

---

## 4. Langkah Percobaan
(Tuliskan langkah yang dilakukan sesuai instruksi.  
Contoh format:
1. Membuat file `caesar_cipher.py` di folder `praktikum/week2-cryptosystem/src/`.
2. Menyalin kode program dari panduan praktikum.
3. Menjalankan program dengan perintah `python caesar_cipher.py`.)

---

## 5. Source Code
```python
import random

class ShamirSecretSharing:
    def __init__(self, prime=2**127 - 1):  # Large prime for finite field
        self.prime = prime

    def _mod_inverse(self, a, m):
        """Extended Euclidean algorithm for modular inverse"""
        m0, y, x = m, 0, 1
        if m == 1:
            return 0
        while a > 1:
            q = a // m
            m, a = a % m, m
            y, x = x - q * y, y
        if x < 0:
            x += m0
        return x

    def _evaluate_polynomial(self, coeffs, x):
        """Evaluate polynomial at point x"""
        result = 0
        for coeff in reversed(coeffs):
            result = (result * x + coeff) % self.prime
        return result

    def _lagrange_interpolation(self, points, x=0):
        """Lagrange interpolation to find f(0)"""
        result = 0
        for i, (xi, yi) in enumerate(points):
            term = yi
            for j, (xj, _) in enumerate(points):
                if i != j:
                    term = term * (x - xj) * self._mod_inverse(xi - xj, self.prime) % self.prime
            result = (result + term) % self.prime
        return result

    def split_secret(self, secret, n, k):
        """Split secret into n shares, requiring k shares to reconstruct"""
        if secret >= self.prime:
            raise ValueError("Secret too large for prime field")
        
        # Generate random coefficients for polynomial of degree k-1
        coeffs = [secret] + [random.randint(0, self.prime - 1) for _ in range(k - 1)]
        
        # Generate n shares
        shares = []
        for i in range(1, n + 1):
            y = self._evaluate_polynomial(coeffs, i)
            shares.append((i, y))
        
        return shares

    def reconstruct_secret(self, shares):
        """Reconstruct secret from shares using Lagrange interpolation"""
        return self._lagrange_interpolation(shares)

# Demo
if __name__ == "__main__":
    sss = ShamirSecretSharing()
    
    # Example: Split secret 12345 into 5 shares, requiring 3 to reconstruct
    secret = 12345
    n = 5  # Total shares
    k = 3  # Threshold
    
    print(f"Original secret: {secret}")
    
    # Split secret
    shares = sss.split_secret(secret, n, k)
    print(f"Generated {n} shares:")
    for share in shares:
        print(f"  Share {share[0]}: {share[1]}")
    
    # Reconstruct with different combinations
    print("\nReconstructing with different combinations:")
    
    # Test with k shares
    subset_k = shares[:k]
    reconstructed = sss.reconstruct_secret(subset_k)
    print(f"With {k} shares {subset_k}: Reconstructed secret = {reconstructed}")
    
    # Test with more than k shares
    subset_more = shares[:k+1]
    reconstructed = sss.reconstruct_secret(subset_more)
    print(f"With {k+1} shares {subset_more}: Reconstructed secret = {reconstructed}")
    
    # Test with less than k shares (should fail)
    subset_less = shares[:k-1]
    reconstructed = sss.reconstruct_secret(subset_less)
    print(f"With {k-1} shares {subset_less}: Reconstructed secret = {reconstructed} (incorrect)")
```

---

## 6. Hasil dan Pembahasan
(- Lampirkan screenshot hasil eksekusi program (taruh di folder `screenshots/`).  
- Berikan tabel atau ringkasan hasil uji jika diperlukan.  
- Jelaskan apakah hasil sesuai ekspektasi.  
- Bahas error (jika ada) dan solusinya. 

Hasil eksekusi program Caesar Cipher:

![Hasil Eksekusi](screenshots/output.png)
![Hasil Input](screenshots/input.png)
![Hasil Output](screenshots/output.png)
)

---

## 7. Jawaban Pertanyaan
- Pertanyaan 1: Apa keuntungan utama dari Secret Sharing dibandingkan enkripsi biasa?  
  Keuntungan utama adalah distribusi risiko - rahasia tidak disimpan di satu tempat saja, sehingga lebih tahan terhadap kompromi tunggal. Selain itu, tidak memerlukan kunci tambahan untuk dekripsi karena rekonstruksi dilakukan secara matematis.

- Pertanyaan 2: Mengapa Shamir's Secret Sharing menggunakan finite field arithmetic?  
  Finite field arithmetic digunakan untuk memastikan operasi matematis (seperti invers modular) selalu terdefinisi dan hasilnya tetap dalam field yang terbatas. Ini mencegah masalah overflow dan memastikan keamanan kriptografis.

- Pertanyaan 3: Bagaimana aplikasi praktis Secret Sharing dalam sistem keamanan?  
  Secret Sharing dapat digunakan dalam sistem multi-signature untuk wallet cryptocurrency, distribusi kunci master dalam sistem perbankan, atau penyimpanan rahasia perusahaan di mana beberapa eksekutif harus menyetujui akses.
---

## 8. Kesimpulan
(Tuliskan kesimpulan singkat (2â€“3 kalimat) berdasarkan percobaan.  )

---

## 9. Daftar Pustaka
- Shamir, A. (1979). How to share a secret. *Communications of the ACM*, 22(11), 612-613.
- Stallings, W. (2017). *Cryptography and Network Security: Principles and Practice* (7th ed.). Pearson.

---

## 10. Commit Log
(Tuliskan bukti commit Git yang relevan.  
Contoh:
```
commit abc12345
Author: Nama Mahasiswa <email>
Date:   2025-09-20

    week2-cryptosystem: implementasi Caesar Cipher dan laporan )
```
